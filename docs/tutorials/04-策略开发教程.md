# ç­–ç•¥å¼€å‘æ•™ç¨‹

æœ¬æ•™ç¨‹å°†æ•™ä½ å¦‚ä½•ä»é›¶å¼€å§‹å¼€å‘è‡ªå·±çš„é‡åŒ–äº¤æ˜“ç­–ç•¥ã€‚

## ğŸ“– ç›®å½•

- [ç­–ç•¥æ¶æ„æ¦‚è§ˆ](#ç­–ç•¥æ¶æ„æ¦‚è§ˆ)
- [StrategyBase åŸºç±»](#strategybase-åŸºç±»)
- [å¼€å‘ä½ çš„ç¬¬ä¸€ä¸ªç­–ç•¥](#å¼€å‘ä½ çš„ç¬¬ä¸€ä¸ªç­–ç•¥)
- [RSI ç­–ç•¥æ·±åº¦è§£æ](#rsi-ç­–ç•¥æ·±åº¦è§£æ)
- [å¸¸ç”¨æŠ€æœ¯æŒ‡æ ‡](#å¸¸ç”¨æŠ€æœ¯æŒ‡æ ‡)
- [ä»“ä½ç®¡ç†](#ä»“ä½ç®¡ç†)
- [é£é™©æ§åˆ¶](#é£é™©æ§åˆ¶)
- [ç­–ç•¥è°ƒè¯•æŠ€å·§](#ç­–ç•¥è°ƒè¯•æŠ€å·§)

## ğŸ—ï¸ ç­–ç•¥æ¶æ„æ¦‚è§ˆ

CryptoQuant ç­–ç•¥åˆ†ä¸ºä¸¤å±‚ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              StrategyBaseï¼ˆæŠ½è±¡åŸºç±»ï¼‰                 â”‚
â”‚          å®šä¹‰ç»Ÿä¸€æ¥å£å’Œä¿¡å·æšä¸¾                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç”¨æˆ·ç­–ç•¥å±‚       â”‚    â”‚  Backtraderé€‚é…å±‚ â”‚
â”‚ (RSIStrategy)    â”‚â”€â”€â”€>â”‚ (Backtrader      â”‚
â”‚ â€¢ ä¿¡å·ç”Ÿæˆ        â”‚    â”‚  Strategy)       â”‚
â”‚ â€¢ æŒ‡æ ‡è®¡ç®—        â”‚    â”‚ â€¢ è®¢å•ç®¡ç†        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â€¢ ä»“ä½è·Ÿè¸ª        â”‚
                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å…³é”®æ¦‚å¿µ

1. **ä¿¡å·ç”Ÿæˆ**ï¼šç­–ç•¥è®¡ç®—æŠ€æœ¯æŒ‡æ ‡ï¼Œè¾“å‡º `Position` æšä¸¾ï¼ˆLONG/SHORT/EXITï¼‰
2. **è®¢å•æ‰§è¡Œ**ï¼šBacktrader æ¥æ”¶ä¿¡å·ï¼Œåˆ›å»ºå¸‚ä»·å•
3. **çŠ¶æ€ç®¡ç†**ï¼šBacktrader è·Ÿè¸ªæŒä»“ã€èµ„é‡‘ã€è®¢å•çŠ¶æ€
4. **å¯è§†åŒ–é›†æˆ**ï¼šç­–ç•¥é€šè¿‡ `plotter` å°†ä¿¡å·å‘é€åˆ°å›¾è¡¨

## ğŸ¯ StrategyBase åŸºç±»

æ‰€æœ‰ç­–ç•¥å¿…é¡»ç»§æ‰¿ `StrategyBase`ã€‚

### æºç ç»“æ„ï¼ˆ`src/strategy/StrategyBase.py`ï¼‰

```python
from enum import Enum
from typing import Optional

class Position(Enum):
    """ä»“ä½ä¿¡å·æšä¸¾"""
    EXIT = 0    # ç©ºä»“/å¹³ä»“
    LONG = 1    # åšå¤š
    SHORT = -1  # åšç©º

class StrategyBase:
    """ç­–ç•¥åŸºç±»"""
    
    def __init__(self, data, **kwargs):
        """
        åˆå§‹åŒ–ç­–ç•¥
        
        Args:
            data: OHLCV æ•°æ®å¯¹è±¡
            **kwargs: ç­–ç•¥å‚æ•°ï¼ˆå¦‚ rsi_period=14ï¼‰
        """
        self.data = data
        self.params = kwargs
    
    def next(self) -> Optional[Position]:
        """
        æ¯æ ¹ K çº¿è°ƒç”¨ä¸€æ¬¡ï¼Œè¿”å›ä»“ä½ä¿¡å·
        
        Returns:
            Position.LONG: åšå¤šä¿¡å·
            Position.SHORT: åšç©ºä¿¡å·
            Position.EXIT: å¹³ä»“ä¿¡å·
            None: ä¸æ“ä½œ
        """
        raise NotImplementedError("å­ç±»å¿…é¡»å®ç° next() æ–¹æ³•")
```

### æ ¸å¿ƒæ–¹æ³•

| æ–¹æ³• | è°ƒç”¨æ—¶æœº | ä½œç”¨ |
|------|---------|------|
| `__init__()` | ç­–ç•¥åˆ›å»ºæ—¶ | åˆå§‹åŒ–å‚æ•°ã€æŒ‡æ ‡ |
| `next()` | æ¯æ ¹ K çº¿ | ç”Ÿæˆäº¤æ˜“ä¿¡å· |

### Position æšä¸¾è¯¦è§£

| æšä¸¾å€¼ | å«ä¹‰ | ä½¿ç”¨åœºæ™¯ |
|--------|------|----------|
| `Position.LONG` | åšå¤š | RSI è¶…å–ã€å‡çº¿é‡‘å‰ |
| `Position.SHORT` | åšç©º | RSI è¶…ä¹°ã€å‡çº¿æ­»å‰ |
| `Position.EXIT` | å¹³ä»“ | æ­¢æŸã€æ­¢ç›ˆã€åè½¬ä¿¡å· |
| `None` | ä¸æ“ä½œ | ä¿¡å·æœªè§¦å‘ã€ç­‰å¾…ç¡®è®¤ |

## ğŸš€ å¼€å‘ä½ çš„ç¬¬ä¸€ä¸ªç­–ç•¥

### ç¤ºä¾‹ï¼šç®€å•å‡çº¿ç­–ç•¥

åˆ›å»º `src/strategy/SMAStrategy.py`ï¼š

```python
from src.strategy.StrategyBase import StrategyBase, Position
import pandas as pd

class SMAStrategy(StrategyBase):
    """ç®€å•ç§»åŠ¨å¹³å‡çº¿ç­–ç•¥"""
    
    def __init__(self, data, short_period=10, long_period=30, **kwargs):
        super().__init__(data, **kwargs)
        
        # ä¿å­˜å‚æ•°
        self.short_period = short_period
        self.long_period = long_period
        
        # åˆå§‹åŒ–æŒ‡æ ‡ï¼ˆç©ºåˆ—è¡¨ï¼Œç¨åè®¡ç®—ï¼‰
        self.sma_short = []
        self.sma_long = []
    
    def next(self) -> Position:
        """
        ç­–ç•¥é€»è¾‘ï¼š
        - çŸ­æœŸå‡çº¿ä¸Šç©¿é•¿æœŸå‡çº¿ â†’ åšå¤š
        - çŸ­æœŸå‡çº¿ä¸‹ç©¿é•¿æœŸå‡çº¿ â†’ å¹³ä»“
        """
        # è·å–æœ€æ–°æ”¶ç›˜ä»·
        close_prices = self.data.close
        
        # è®¡ç®—å‡çº¿ï¼ˆä½¿ç”¨æœ€è¿‘çš„ N æ ¹ K çº¿ï¼‰
        if len(close_prices) >= self.long_period:
            self.sma_short.append(
                sum(close_prices[-self.short_period:]) / self.short_period
            )
            self.sma_long.append(
                sum(close_prices[-self.long_period:]) / self.long_period
            )
        else:
            return None  # æ•°æ®ä¸è¶³ï¼Œä¸æ“ä½œ
        
        # é‡‘å‰ï¼šçŸ­æœŸå‡çº¿ä»ä¸‹å‘ä¸Šç©¿è¿‡é•¿æœŸå‡çº¿
        if len(self.sma_short) >= 2:
            prev_short = self.sma_short[-2]
            prev_long = self.sma_long[-2]
            curr_short = self.sma_short[-1]
            curr_long = self.sma_long[-1]
            
            # é‡‘å‰ â†’ åšå¤š
            if prev_short <= prev_long and curr_short > curr_long:
                return Position.LONG
            
            # æ­»å‰ â†’ å¹³ä»“
            if prev_short >= prev_long and curr_short < curr_long:
                return Position.EXIT
        
        return None  # æ— ä¿¡å·
```

### åˆ›å»º Backtrader é€‚é…å™¨

åˆ›å»º `src/strategy/SMAStrategy.py`ï¼ˆç»­ï¼‰ï¼š

```python
import backtrader as bt

class SMABacktraderStrategy(bt.Strategy):
    """Backtrader é€‚é…å™¨"""
    
    params = (
        ('short_period', 10),
        ('long_period', 30),
        ('printlog', False),
        ('plotter', None),
    )
    
    def __init__(self):
        # åˆå§‹åŒ–ç”¨æˆ·ç­–ç•¥
        self.strategy = SMAStrategy(
            data=self.data,
            short_period=self.params.short_period,
            long_period=self.params.long_period
        )
        
        # å½“å‰ä»“ä½
        self.current_position = Position.EXIT
        self.order = None
    
    def next(self):
        # è°ƒç”¨ç”¨æˆ·ç­–ç•¥
        signal = self.strategy.next()
        
        if signal is None:
            return
        
        # æ‰§è¡Œä¿¡å·
        if signal == Position.LONG and self.current_position != Position.LONG:
            if self.current_position != Position.EXIT:
                self.close()  # å…ˆå¹³ä»“
            self.order = self.buy()
            self.current_position = Position.LONG
            
            # æ·»åŠ åˆ°å›¾è¡¨
            if self.params.plotter:
                self.params.plotter.add_buy_signal(
                    time=self.data.datetime.datetime(0),
                    price=self.data.close[0]
                )
        
        elif signal == Position.EXIT and self.current_position != Position.EXIT:
            self.close()
            self.current_position = Position.EXIT
            
            # æ·»åŠ åˆ°å›¾è¡¨
            if self.params.plotter:
                self.params.plotter.add_close_signal(
                    time=self.data.datetime.datetime(0),
                    price=self.data.close[0]
                )
```

### è¿è¡Œç­–ç•¥

åˆ›å»º `script/run_sma_backtest.py`ï¼š

```python
from src.backtest.engine import quick_backtest
from src.strategy.SMAStrategy import SMABacktraderStrategy

results = quick_backtest(
    csv_path='data/btc-usdt-5m.csv',
    strategy_class=SMABacktraderStrategy,
    strategy_params={
        'short_period': 10,
        'long_period': 30,
        'printlog': False
    },
    initial_cash=10000.0,
    commission=0.0004,
    output_dir='./reports',
    strategy_name='BTC_SMA_5m'
)

print(f"æ”¶ç›Šç‡: {results['return_pct']:.2f}%")
```

è¿è¡Œï¼š

```bash
python script/run_sma_backtest.py
```

## ğŸ“Š RSI ç­–ç•¥æ·±åº¦è§£æ

ç°åœ¨æ·±å…¥åˆ†æé¡¹ç›®è‡ªå¸¦çš„ RSI ç­–ç•¥ã€‚

### RSI æŒ‡æ ‡åŸç†

RSIï¼ˆRelative Strength Indexï¼Œç›¸å¯¹å¼ºå¼±æŒ‡æ ‡ï¼‰è¡¡é‡ä»·æ ¼å˜åŠ¨çš„é€Ÿåº¦å’Œå¹…åº¦ï¼š

$$
RSI = 100 - \frac{100}{1 + RS}
$$

å…¶ä¸­ï¼š

$$
RS = \frac{\text{å¹³å‡æ¶¨å¹…}}{\text{å¹³å‡è·Œå¹…}}
$$

- **RSI < 30**ï¼šè¶…å–ï¼Œå¯èƒ½åå¼¹ â†’ ä¹°å…¥
- **RSI > 70**ï¼šè¶…ä¹°,å¯èƒ½å›è°ƒ â†’ å–å‡º

### RSI ç­–ç•¥æºç è§£æï¼ˆ`src/strategy/RSIStrategy.py`ï¼‰

#### 1. åˆå§‹åŒ–éƒ¨åˆ†

```python
class RSIStrategy(StrategyBase):
    def __init__(self, data, rsi_period=14, rsi_oversold=30, 
                 rsi_overbought=70, **kwargs):
        super().__init__(data, **kwargs)
        
        # ä¿å­˜å‚æ•°
        self.rsi_period = rsi_period       # RSI å‘¨æœŸï¼ˆé»˜è®¤ 14ï¼‰
        self.rsi_oversold = rsi_oversold   # è¶…å–çº¿ï¼ˆé»˜è®¤ 30ï¼‰
        self.rsi_overbought = rsi_overbought # è¶…ä¹°çº¿ï¼ˆé»˜è®¤ 70ï¼‰
        
        # RSI å€¼åˆ—è¡¨ï¼ˆå­˜å‚¨å†å² RSIï¼‰
        self.rsi_values = []
```

**å‚æ•°è¯´æ˜ï¼š**
- `rsi_period=14`ï¼šä½¿ç”¨æœ€è¿‘ 14 æ ¹ K çº¿è®¡ç®— RSI
- `rsi_oversold=30`ï¼šRSI ä½äº 30 æ—¶ä¹°å…¥
- `rsi_overbought=70`ï¼šRSI é«˜äº 70 æ—¶å–å‡º

#### 2. RSI è®¡ç®—

```python
def next(self) -> Position:
    close_prices = self.data.close
    
    # æ•°æ®ä¸è¶³ï¼Œä¸è®¡ç®—
    if len(close_prices) < self.rsi_period + 1:
        return None
    
    # ä½¿ç”¨ talib è®¡ç®— RSI
    close_array = np.array(close_prices[-(self.rsi_period + 100):])
    rsi_array = talib.RSI(close_array, timeperiod=self.rsi_period)
    current_rsi = rsi_array[-1]
    
    # ä¿å­˜ RSI å€¼
    self.rsi_values.append(current_rsi)
```

**å…³é”®ç‚¹ï¼š**
- ä½¿ç”¨ `talib.RSI()` è®¡ç®—ï¼ˆé«˜æ•ˆã€å‡†ç¡®ï¼‰
- ä¿ç•™é¢å¤– 100 æ ¹ K çº¿ï¼ˆtalib éœ€è¦é¢„çƒ­ï¼‰
- åªå–æœ€åä¸€ä¸ªå€¼ `rsi_array[-1]`

#### 3. äº¤æ˜“ä¿¡å·ç”Ÿæˆ

```python
    # è¶…å– â†’ åšå¤š
    if current_rsi < self.rsi_oversold:
        return Position.LONG
    
    # è¶…ä¹° â†’ å¹³ä»“
    elif current_rsi > self.rsi_overbought:
        return Position.EXIT
    
    return None  # æ— ä¿¡å·
```

**é€»è¾‘æ€»ç»“ï¼š**

| RSI èŒƒå›´ | ä¿¡å· | è¯´æ˜ |
|----------|------|------|
| RSI < 30 | `Position.LONG` | è¶…å–ï¼Œä¹°å…¥ |
| 30 â‰¤ RSI â‰¤ 70 | `None` | æ­£å¸¸åŒºé—´ï¼ŒæŒä»“ä¸åŠ¨ |
| RSI > 70 | `Position.EXIT` | è¶…ä¹°ï¼Œå¹³ä»“ |

### Backtrader é€‚é…å™¨éƒ¨åˆ†

```python
class RSIBacktraderStrategy(bt.Strategy):
    params = (
        ('rsi_period', 14),
        ('rsi_oversold', 30),
        ('rsi_overbought', 70),
        ('printlog', False),
        ('plotter', None),
    )
    
    def __init__(self):
        # åˆ›å»ºç”¨æˆ·ç­–ç•¥å®ä¾‹
        self.strategy = RSIStrategy(
            data=self.data,
            rsi_period=self.params.rsi_period,
            rsi_oversold=self.params.rsi_oversold,
            rsi_overbought=self.params.rsi_overbought
        )
        
        self.current_position = Position.EXIT
        self.order = None
    
    def next(self):
        # æœ‰æœªå®Œæˆè®¢å•ï¼Œç­‰å¾…
        if self.order:
            return
        
        # è°ƒç”¨ç”¨æˆ·ç­–ç•¥
        signal = self.strategy.next()
        
        if signal is None:
            return
        
        # å¤„ç†åšå¤šä¿¡å·
        if signal == Position.LONG and self.current_position != Position.LONG:
            if self.current_position != Position.EXIT:
                self.close()  # å…ˆå¹³ä»“
            
            # è®¡ç®—ä»“ä½å¤§å°ï¼ˆ95% èµ„é‡‘ï¼Œç•™ 5% åº”å¯¹æ‰‹ç»­è´¹ï¼‰
            size = (self.broker.getcash() * 0.95) / self.data.close[0]
            self.order = self.buy(size=size)
            self.current_position = Position.LONG
            
            # æ·»åŠ ä¹°å…¥æ ‡è®°
            if self.params.plotter:
                self.params.plotter.add_buy_signal(
                    time=self.data.datetime.datetime(0),
                    price=self.data.close[0]
                )
        
        # å¤„ç†å¹³ä»“ä¿¡å·
        elif signal == Position.EXIT and self.current_position != Position.EXIT:
            self.order = self.close()
            self.current_position = Position.EXIT
            
            # æ·»åŠ å¹³ä»“æ ‡è®°
            if self.params.plotter:
                self.params.plotter.add_close_signal(
                    time=self.data.datetime.datetime(0),
                    price=self.data.close[0]
                )
    
    def notify_order(self, order):
        """è®¢å•çŠ¶æ€å›è°ƒ"""
        if order.status in [order.Completed]:
            if order.isbuy():
                self.log(f'ä¹°å…¥æ‰§è¡Œ, ä»·æ ¼: {order.executed.price:.2f}, '
                        f'æ•°é‡: {order.executed.size:.4f}')
            else:
                self.log(f'å–å‡ºæ‰§è¡Œ, ä»·æ ¼: {order.executed.price:.2f}, '
                        f'æ•°é‡: {order.executed.size:.4f}')
            
            self.order = None  # è®¢å•å®Œæˆï¼Œæ¸…ç©º
        
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('è®¢å•å–æ¶ˆ/ä¿è¯é‡‘ä¸è¶³/è¢«æ‹’ç»')
            self.order = None
```

**å…³é”®ç‚¹ï¼š**
- **ä»“ä½è®¡ç®—**ï¼š`size = cash * 0.95 / price`ï¼ˆä½¿ç”¨ 95% èµ„é‡‘ï¼‰
- **çŠ¶æ€ç®¡ç†**ï¼š`current_position` è·Ÿè¸ªå½“å‰ä»“ä½
- **è®¢å•é”**ï¼š`self.order` é˜²æ­¢é‡å¤ä¸‹å•
- **å›¾è¡¨é›†æˆ**ï¼š`plotter.add_buy_signal()` æ ‡è®°ä¹°å…¥ç‚¹

## ğŸ› ï¸ å¸¸ç”¨æŠ€æœ¯æŒ‡æ ‡

### 1. å‡çº¿ï¼ˆMoving Averageï¼‰

```python
import talib

# ç®€å•ç§»åŠ¨å¹³å‡ï¼ˆSMAï¼‰
sma = talib.SMA(close_prices, timeperiod=20)

# æŒ‡æ•°ç§»åŠ¨å¹³å‡ï¼ˆEMAï¼‰
ema = talib.EMA(close_prices, timeperiod=20)

# åŒå‡çº¿äº¤å‰
if sma_short[-1] > sma_long[-1] and sma_short[-2] <= sma_long[-2]:
    return Position.LONG  # é‡‘å‰
```

### 2. MACD

```python
macd, signal, hist = talib.MACD(
    close_prices,
    fastperiod=12,
    slowperiod=26,
    signalperiod=9
)

# MACD é‡‘å‰
if macd[-1] > signal[-1] and macd[-2] <= signal[-2]:
    return Position.LONG
```

### 3. å¸ƒæ—å¸¦ï¼ˆBollinger Bandsï¼‰

```python
upper, middle, lower = talib.BBANDS(
    close_prices,
    timeperiod=20,
    nbdevup=2,
    nbdevdn=2
)

# ä»·æ ¼è§¦åŠä¸‹è½¨ â†’ è¶…å–
if close_prices[-1] <= lower[-1]:
    return Position.LONG

# ä»·æ ¼è§¦åŠä¸Šè½¨ â†’ è¶…ä¹°
if close_prices[-1] >= upper[-1]:
    return Position.EXIT
```

### 4. KDJ

```python
slowk, slowd = talib.STOCH(
    high_prices,
    low_prices,
    close_prices,
    fastk_period=9,
    slowk_period=3,
    slowd_period=3
)

# K çº¿é‡‘å‰ D çº¿
if slowk[-1] > slowd[-1] and slowk[-2] <= slowd[-2]:
    if slowk[-1] < 20:  # ä½ä½é‡‘å‰
        return Position.LONG
```

### 5. ATRï¼ˆAverage True Rangeï¼‰

ç”¨äºæ­¢æŸä½è®¡ç®—ï¼š

```python
atr = talib.ATR(high_prices, low_prices, close_prices, timeperiod=14)

# æ­¢æŸä½ = å…¥åœºä»· - 2 * ATR
stop_loss = entry_price - 2 * atr[-1]
```

## ğŸ’° ä»“ä½ç®¡ç†

### 1. å›ºå®šèµ„é‡‘ç™¾åˆ†æ¯”

```python
# ä½¿ç”¨ 50% èµ„é‡‘
size = (self.broker.getcash() * 0.5) / self.data.close[0]
self.buy(size=size)
```

### 2. å‡¯åˆ©å…¬å¼ï¼ˆKelly Criterionï¼‰

```python
def calculate_kelly(win_rate, avg_win, avg_loss):
    """
    å‡¯åˆ©å…¬å¼è®¡ç®—æœ€ä¼˜ä»“ä½
    
    Args:
        win_rate: èƒœç‡ï¼ˆ0-1ï¼‰
        avg_win: å¹³å‡ç›ˆåˆ©
        avg_loss: å¹³å‡äºæŸ
    
    Returns:
        kelly: æœ€ä¼˜ä»“ä½æ¯”ä¾‹ï¼ˆ0-1ï¼‰
    """
    if avg_loss == 0:
        return 0
    
    win_loss_ratio = avg_win / abs(avg_loss)
    kelly = win_rate - (1 - win_rate) / win_loss_ratio
    
    # é™åˆ¶æœ€å¤§ 25%
    return max(0, min(kelly, 0.25))

# ä½¿ç”¨å‡¯åˆ©ä»“ä½
kelly = calculate_kelly(win_rate=0.55, avg_win=200, avg_loss=100)
size = (self.broker.getcash() * kelly) / self.data.close[0]
```

### 3. é©¬ä¸æ ¼å°”ï¼ˆåŠ å€æ³•ï¼Œé«˜é£é™©ï¼‰

```python
class MartingaleStrategy(bt.Strategy):
    def __init__(self):
        self.base_size = 0.01  # åŸºç¡€ä»“ä½
        self.current_size = self.base_size
        self.loss_count = 0
    
    def notify_trade(self, trade):
        if trade.isclosed:
            if trade.pnl < 0:
                # äºæŸ â†’ ä»“ä½ç¿»å€
                self.loss_count += 1
                self.current_size = self.base_size * (2 ** self.loss_count)
            else:
                # ç›ˆåˆ© â†’ é‡ç½®ä»“ä½
                self.loss_count = 0
                self.current_size = self.base_size
    
    def next(self):
        if signal == Position.LONG:
            self.buy(size=self.current_size)
```

## ğŸ›¡ï¸ é£é™©æ§åˆ¶

### 1. å›ºå®šæ­¢æŸ

```python
class StopLossStrategy(bt.Strategy):
    params = (('stop_loss_pct', 0.02),)  # 2% æ­¢æŸ
    
    def __init__(self):
        self.entry_price = None
    
    def next(self):
        # ä¹°å…¥åè®°å½•å…¥åœºä»·
        if signal == Position.LONG:
            self.buy()
            self.entry_price = self.data.close[0]
        
        # æ£€æŸ¥æ­¢æŸ
        if self.entry_price is not None:
            current_price = self.data.close[0]
            loss_pct = (current_price - self.entry_price) / self.entry_price
            
            if loss_pct < -self.params.stop_loss_pct:
                self.close()
                self.entry_price = None
                print(f"è§¦å‘æ­¢æŸ: {loss_pct*100:.2f}%")
```

### 2. è¿½è¸ªæ­¢æŸ

```python
class TrailingStopStrategy(bt.Strategy):
    params = (('trailing_pct', 0.05),)  # 5% è¿½è¸ªæ­¢æŸ
    
    def __init__(self):
        self.highest_price = None
    
    def next(self):
        if self.position:
            current_price = self.data.close[0]
            
            # æ›´æ–°æœ€é«˜ä»·
            if self.highest_price is None or current_price > self.highest_price:
                self.highest_price = current_price
            
            # è®¡ç®—å›æ’¤
            drawdown = (current_price - self.highest_price) / self.highest_price
            
            if drawdown < -self.params.trailing_pct:
                self.close()
                self.highest_price = None
                print(f"è§¦å‘è¿½è¸ªæ­¢æŸï¼Œå›æ’¤: {drawdown*100:.2f}%")
```

### 3. æ—¶é—´æ­¢æŸ

```python
class TimeStopStrategy(bt.Strategy):
    params = (('max_holding_bars', 100),)  # æœ€å¤šæŒä»“ 100 æ ¹ K çº¿
    
    def __init__(self):
        self.entry_bar = None
    
    def next(self):
        if signal == Position.LONG:
            self.buy()
            self.entry_bar = len(self.data)
        
        # æ£€æŸ¥æŒä»“æ—¶é—´
        if self.position and self.entry_bar is not None:
            holding_bars = len(self.data) - self.entry_bar
            
            if holding_bars >= self.params.max_holding_bars:
                self.close()
                self.entry_bar = None
                print(f"æ—¶é—´æ­¢æŸ: æŒä»“ {holding_bars} æ ¹ K çº¿")
```

### 4. æœ€å¤§å›æ’¤æ§åˆ¶

```python
class DrawdownControlStrategy(bt.Strategy):
    params = (('max_drawdown', 0.10),)  # æœ€å¤§å›æ’¤ 10%
    
    def __init__(self):
        self.peak_value = self.broker.getvalue()
    
    def next(self):
        current_value = self.broker.getvalue()
        
        # æ›´æ–°æœ€é«˜å‡€å€¼
        if current_value > self.peak_value:
            self.peak_value = current_value
        
        # è®¡ç®—å›æ’¤
        drawdown = (self.peak_value - current_value) / self.peak_value
        
        if drawdown > self.params.max_drawdown:
            # å¹³æ‰æ‰€æœ‰ä»“ä½
            if self.position:
                self.close()
            print(f"è§¦å‘æœ€å¤§å›æ’¤ä¿æŠ¤: {drawdown*100:.2f}%")
            # åœæ­¢äº¤æ˜“ï¼ˆå¯è®¾ç½®å†·å´æœŸï¼‰
```

## ğŸ› ç­–ç•¥è°ƒè¯•æŠ€å·§

### 1. æ‰“å°æ—¥å¿—

```python
class DebugStrategy(bt.Strategy):
    params = (('printlog', True),)
    
    def log(self, txt, dt=None):
        """ç»Ÿä¸€æ—¥å¿—å‡½æ•°"""
        if self.params.printlog:
            dt = dt or self.data.datetime.datetime(0)
            print(f'{dt.isoformat()} {txt}')
    
    def next(self):
        self.log(f'æ”¶ç›˜ä»·: {self.data.close[0]:.2f}, '
                 f'RSI: {self.rsi[0]:.2f}, '
                 f'æŒä»“: {self.position.size:.4f}')
```

### 2. åˆ†æ­¥éªŒè¯

```python
# 1. å…ˆéªŒè¯æŒ‡æ ‡è®¡ç®—
rsi = talib.RSI(close_prices, 14)
print(f"RSI æœ€å 10 ä¸ªå€¼: {rsi[-10:]}")

# 2. éªŒè¯ä¿¡å·ç”Ÿæˆ
if rsi[-1] < 30:
    print(f"è§¦å‘ä¹°å…¥ä¿¡å·: RSI={rsi[-1]:.2f}")

# 3. éªŒè¯è®¢å•æ‰§è¡Œ
self.log(f'ä¹°å…¥è®¢å•å·²æäº¤ï¼Œä»·æ ¼: {self.data.close[0]:.2f}')
```

### 3. ä½¿ç”¨æ–­è¨€

```python
def next(self):
    # ç¡®ä¿æ•°æ®æœ‰æ•ˆ
    assert self.data.close[0] > 0, "æ”¶ç›˜ä»·æ— æ•ˆ"
    assert len(self.data.close) >= self.rsi_period, "æ•°æ®ä¸è¶³"
    
    # ç¡®ä¿ RSI åœ¨åˆç†èŒƒå›´
    assert 0 <= current_rsi <= 100, f"RSI å¼‚å¸¸: {current_rsi}"
```

### 4. å¯è§†åŒ–æŒ‡æ ‡

åœ¨å›¾è¡¨ä¸­æ·»åŠ è‡ªå®šä¹‰æŒ‡æ ‡ï¼š

```python
# åœ¨ Backtrader ç­–ç•¥ä¸­
def __init__(self):
    self.rsi = bt.indicators.RSI(self.data.close, period=14)
    # Backtrader ä¼šè‡ªåŠ¨åœ¨å›¾è¡¨ä¸­ç»˜åˆ¶ self.rsi
```

æˆ–è€…å¯¼å‡ºæ•°æ®åˆ° CSV åˆ†æï¼š

```python
def stop(self):
    """å›æµ‹ç»“æŸåå¯¼å‡ºæ•°æ®"""
    df = pd.DataFrame({
        'datetime': self.datetime_list,
        'close': self.close_list,
        'rsi': self.rsi_list,
        'signal': self.signal_list
    })
    df.to_csv('backtest_analysis.csv', index=False)
```

---

ğŸ“Œ **ä¸‹ä¸€æ­¥**ï¼šé˜…è¯» [è¿›é˜¶åŠŸèƒ½ä¸æœ€ä½³å®è·µ](./05-è¿›é˜¶åŠŸèƒ½.md) äº†è§£å‚æ•°ä¼˜åŒ–ã€å¤šç­–ç•¥ç»„åˆã€å®ç›˜æ¥å…¥ç­‰é«˜çº§ä¸»é¢˜ã€‚
