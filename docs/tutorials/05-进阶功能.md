# è¿›é˜¶åŠŸèƒ½ä¸æœ€ä½³å®è·µ

æœ¬æŒ‡å—æ¶µç›–å‚æ•°ä¼˜åŒ–ã€å¤šç­–ç•¥ç»„åˆã€æ€§èƒ½è°ƒä¼˜ã€å®ç›˜æ¥å…¥ç­‰é«˜çº§ä¸»é¢˜ã€‚

## ğŸ“– ç›®å½•

- [å‚æ•°ä¼˜åŒ–](#å‚æ•°ä¼˜åŒ–)
- [å¤šç­–ç•¥ç»„åˆ](#å¤šç­–ç•¥ç»„åˆ)
- [æ€§èƒ½è°ƒä¼˜](#æ€§èƒ½è°ƒä¼˜)
- [å›æµ‹é™·é˜±ä¸é˜²èŒƒ](#å›æµ‹é™·é˜±ä¸é˜²èŒƒ)
- [å®ç›˜æ¥å…¥æŒ‡å—](#å®ç›˜æ¥å…¥æŒ‡å—)
- [å¸¸è§é—®é¢˜FAQ](#å¸¸è§é—®é¢˜faq)
- [é¡¹ç›®éƒ¨ç½²](#é¡¹ç›®éƒ¨ç½²)

## ğŸ”¬ å‚æ•°ä¼˜åŒ–

### 1. ç½‘æ ¼æœç´¢ï¼ˆGrid Searchï¼‰

ç©·ä¸¾æ‰€æœ‰å‚æ•°ç»„åˆï¼Œæ‰¾åˆ°æœ€ä¼˜è§£ã€‚

```python
import backtrader as bt
from src.strategy.RSIStrategy import RSIBacktraderStrategy

cerebro = bt.Cerebro(optreturn=False)

# æ·»åŠ ä¼˜åŒ–å‚æ•°èŒƒå›´
cerebro.optstrategy(
    RSIBacktraderStrategy,
    rsi_period=range(10, 21, 2),        # [10, 12, 14, 16, 18, 20]
    rsi_oversold=range(20, 36, 5),      # [20, 25, 30, 35]
    rsi_overbought=range(65, 81, 5)     # [65, 70, 75, 80]
)

# åŠ è½½æ•°æ®
data = bt.feeds.GenericCSVData(
    dataname='data/btc-usdt-5m.csv',
    dtformat='%Y-%m-%d %H:%M:%S',
    datetime=1,
    open=2,
    high=3,
    low=4,
    close=5,
    volume=6,
    openinterest=-1
)
cerebro.adddata(data)

# è®¾ç½®åˆå§‹èµ„é‡‘
cerebro.broker.setcash(10000.0)
cerebro.broker.setcommission(0.0004)

# è¿è¡Œä¼˜åŒ–
results = cerebro.run()

# åˆ†æç»“æœ
print(f"æ€»è®¡æµ‹è¯• {len(results)} ç»„å‚æ•°")

best_result = None
best_value = 0

for result in results:
    strat = result[0]
    final_value = strat.broker.getvalue()
    
    if final_value > best_value:
        best_value = final_value
        best_result = strat
    
    print(f"RSIå‘¨æœŸ={strat.params.rsi_period}, "
          f"è¶…å–çº¿={strat.params.rsi_oversold}, "
          f"è¶…ä¹°çº¿={strat.params.rsi_overbought} â†’ "
          f"æœŸæœ«èµ„é‡‘={final_value:.2f}")

print(f"\næœ€ä½³å‚æ•°: RSIå‘¨æœŸ={best_result.params.rsi_period}, "
      f"è¶…å–çº¿={best_result.params.rsi_oversold}, "
      f"è¶…ä¹°çº¿={best_result.params.rsi_overbought}")
print(f"æœ€é«˜æ”¶ç›Š: {(best_value - 10000) / 10000 * 100:.2f}%")
```

**æ³¨æ„äº‹é¡¹ï¼š**
- å‚æ•°ç»„åˆæ•° = 6 Ã— 4 Ã— 4 = 96 ç»„
- ä¼˜åŒ–è€—æ—¶ â‰ˆ å•æ¬¡å›æµ‹æ—¶é—´ Ã— ç»„åˆæ•°
- å¯èƒ½å­˜åœ¨è¿‡æ‹Ÿåˆé£é™©ï¼ˆè§ä¸‹æ–‡ï¼‰

### 2. éšæœºæœç´¢ï¼ˆRandom Searchï¼‰

éšæœºé‡‡æ ·å‚æ•°ç©ºé—´ï¼Œé€‚åˆé«˜ç»´å‚æ•°ä¼˜åŒ–ã€‚

```python
import random

def random_search(n_iter=100):
    """éšæœºæœç´¢æœ€ä¼˜å‚æ•°"""
    results = []
    
    for i in range(n_iter):
        # éšæœºç”Ÿæˆå‚æ•°
        params = {
            'rsi_period': random.randint(10, 20),
            'rsi_oversold': random.randint(20, 35),
            'rsi_overbought': random.randint(65, 80)
        }
        
        # è¿è¡Œå›æµ‹
        engine = BacktestEngine(initial_cash=10000.0)
        engine.setup(RSIBacktraderStrategy, params)
        engine.load_data('data/btc-usdt-5m.csv')
        engine.run()
        
        final_value = engine.get_final_value()
        results.append((params, final_value))
        
        print(f"[{i+1}/{n_iter}] {params} â†’ {final_value:.2f}")
    
    # æ‰¾åˆ°æœ€ä½³å‚æ•°
    best_params, best_value = max(results, key=lambda x: x[1])
    print(f"\næœ€ä½³å‚æ•°: {best_params}")
    print(f"æœ€é«˜æ”¶ç›Š: {(best_value - 10000) / 10000 * 100:.2f}%")
    
    return best_params

# è¿è¡Œéšæœºæœç´¢
best_params = random_search(n_iter=50)
```

### 3. Walk-Forward ä¼˜åŒ–ï¼ˆæ¨èï¼‰

é¿å…è¿‡æ‹Ÿåˆçš„ä¼˜åŒ–æ–¹æ³•ï¼š

1. **è®­ç»ƒæœŸ**ï¼š2024-01-01 åˆ° 2024-06-30ï¼ˆä¼˜åŒ–å‚æ•°ï¼‰
2. **æµ‹è¯•æœŸ**ï¼š2024-07-01 åˆ° 2024-09-30ï¼ˆéªŒè¯å‚æ•°ï¼‰
3. **æ»šåŠ¨çª—å£**ï¼šä¾æ¬¡å‘å‰æ»‘åŠ¨

```python
from datetime import datetime, timedelta
import pandas as pd

def walk_forward_optimization(
    csv_path='data/btc-usdt-5m.csv',
    train_months=6,
    test_months=3,
    step_months=3
):
    """
    Walk-Forward ä¼˜åŒ–
    
    Args:
        csv_path: æ•°æ®æ–‡ä»¶è·¯å¾„
        train_months: è®­ç»ƒæœŸé•¿åº¦ï¼ˆæœˆï¼‰
        test_months: æµ‹è¯•æœŸé•¿åº¦ï¼ˆæœˆï¼‰
        step_months: æ»‘åŠ¨æ­¥é•¿ï¼ˆæœˆï¼‰
    """
    df = pd.read_csv(csv_path)
    df['datetime'] = pd.to_datetime(df['datetime'])
    
    start_date = df['datetime'].min()
    end_date = df['datetime'].max()
    
    results = []
    
    current_date = start_date
    while current_date + timedelta(days=train_months*30 + test_months*30) <= end_date:
        # åˆ’åˆ†è®­ç»ƒé›†å’Œæµ‹è¯•é›†
        train_start = current_date
        train_end = train_start + timedelta(days=train_months*30)
        test_start = train_end
        test_end = test_start + timedelta(days=test_months*30)
        
        train_df = df[(df['datetime'] >= train_start) & (df['datetime'] < train_end)]
        test_df = df[(df['datetime'] >= test_start) & (df['datetime'] < test_end)]
        
        # ä¿å­˜ä¸´æ—¶æ–‡ä»¶
        train_df.to_csv('temp_train.csv', index=False)
        test_df.to_csv('temp_test.csv', index=False)
        
        # ç¬¬ä¸€æ­¥ï¼šåœ¨è®­ç»ƒé›†ä¸Šä¼˜åŒ–å‚æ•°
        print(f"\n{'='*60}")
        print(f"è®­ç»ƒæœŸ: {train_start.date()} è‡³ {train_end.date()}")
        print(f"{'='*60}")
        
        best_params = optimize_on_dataset('temp_train.csv')
        
        # ç¬¬äºŒæ­¥ï¼šåœ¨æµ‹è¯•é›†ä¸ŠéªŒè¯å‚æ•°
        print(f"\n{'='*60}")
        print(f"æµ‹è¯•æœŸ: {test_start.date()} è‡³ {test_end.date()}")
        print(f"{'='*60}")
        
        engine = BacktestEngine(initial_cash=10000.0)
        engine.setup(RSIBacktraderStrategy, best_params)
        engine.load_data('temp_test.csv')
        engine.run()
        
        final_value = engine.get_final_value()
        return_pct = (final_value - 10000) / 10000 * 100
        
        results.append({
            'train_period': f"{train_start.date()} ~ {train_end.date()}",
            'test_period': f"{test_start.date()} ~ {test_end.date()}",
            'params': best_params,
            'return_pct': return_pct
        })
        
        print(f"æµ‹è¯•æœŸæ”¶ç›Š: {return_pct:.2f}%")
        
        # æ»‘åŠ¨çª—å£
        current_date += timedelta(days=step_months*30)
    
    # æ±‡æ€»ç»“æœ
    print(f"\n{'='*60}")
    print("Walk-Forward ä¼˜åŒ–ç»“æœæ±‡æ€»")
    print(f"{'='*60}")
    
    for i, result in enumerate(results):
        print(f"\nçª—å£ {i+1}:")
        print(f"  è®­ç»ƒæœŸ: {result['train_period']}")
        print(f"  æµ‹è¯•æœŸ: {result['test_period']}")
        print(f"  æœ€ä¼˜å‚æ•°: {result['params']}")
        print(f"  æµ‹è¯•æ”¶ç›Š: {result['return_pct']:.2f}%")
    
    avg_return = sum(r['return_pct'] for r in results) / len(results)
    print(f"\nå¹³å‡æµ‹è¯•æ”¶ç›Š: {avg_return:.2f}%")

def optimize_on_dataset(csv_path):
    """åœ¨æŒ‡å®šæ•°æ®é›†ä¸Šä¼˜åŒ–å‚æ•°"""
    # è¿™é‡Œç®€åŒ–ä¸ºéšæœºæœç´¢ï¼Œä¹Ÿå¯ç”¨ç½‘æ ¼æœç´¢
    best_params = None
    best_value = 0
    
    for _ in range(20):  # æµ‹è¯• 20 ç»„å‚æ•°
        params = {
            'rsi_period': random.randint(10, 20),
            'rsi_oversold': random.randint(20, 35),
            'rsi_overbought': random.randint(65, 80)
        }
        
        engine = BacktestEngine(initial_cash=10000.0)
        engine.setup(RSIBacktraderStrategy, params)
        engine.load_data(csv_path)
        engine.run()
        
        final_value = engine.get_final_value()
        
        if final_value > best_value:
            best_value = final_value
            best_params = params
    
    return best_params

# è¿è¡Œ Walk-Forward ä¼˜åŒ–
walk_forward_optimization(
    csv_path='data/btc-usdt-5m.csv',
    train_months=6,
    test_months=3,
    step_months=3
)
```

## ğŸ¯ å¤šç­–ç•¥ç»„åˆ

### 1. ç­–ç•¥è½®æ¢ï¼ˆStrategy Rotationï¼‰

æ ¹æ®å¸‚åœºçŠ¶æ€åˆ‡æ¢ç­–ç•¥ï¼š

```python
class StrategyRotation(bt.Strategy):
    """
    ç­–ç•¥è½®æ¢ï¼š
    - è¶‹åŠ¿å¸‚ï¼šä½¿ç”¨å‡çº¿ç­–ç•¥
    - éœ‡è¡å¸‚ï¼šä½¿ç”¨ RSI ç­–ç•¥
    """
    
    def __init__(self):
        # åˆå§‹åŒ–å¤šä¸ªç­–ç•¥
        self.sma_strategy = SMAStrategy(self.data, short_period=10, long_period=30)
        self.rsi_strategy = RSIStrategy(self.data, rsi_period=14)
        
        # è®¡ç®— ATR åˆ¤æ–­å¸‚åœºçŠ¶æ€
        self.atr = bt.indicators.ATR(self.data, period=14)
        self.atr_avg = bt.indicators.SMA(self.atr, period=50)
        
        self.current_strategy = None
    
    def next(self):
        # åˆ¤æ–­å¸‚åœºçŠ¶æ€
        if self.atr[0] > self.atr_avg[0] * 1.2:
            # é«˜æ³¢åŠ¨ â†’ è¶‹åŠ¿å¸‚ â†’ ä½¿ç”¨å‡çº¿ç­–ç•¥
            self.current_strategy = 'sma'
            signal = self.sma_strategy.next()
        else:
            # ä½æ³¢åŠ¨ â†’ éœ‡è¡å¸‚ â†’ ä½¿ç”¨ RSI ç­–ç•¥
            self.current_strategy = 'rsi'
            signal = self.rsi_strategy.next()
        
        # æ‰§è¡Œä¿¡å·
        self.execute_signal(signal)
```

### 2. ç­–ç•¥æŠ•ç¥¨ï¼ˆStrategy Votingï¼‰

å¤šä¸ªç­–ç•¥æŠ•ç¥¨å†³å®šæœ€ç»ˆä¿¡å·ï¼š

```python
class StrategyVoting(bt.Strategy):
    """
    ç­–ç•¥æŠ•ç¥¨ï¼šéœ€è¦è‡³å°‘ 2/3 ç­–ç•¥åŒæ„æ‰äº¤æ˜“
    """
    
    def __init__(self):
        self.strategies = [
            RSIStrategy(self.data, rsi_period=14),
            SMAStrategy(self.data, short_period=10, long_period=30),
            MACDStrategy(self.data)
        ]
    
    def next(self):
        # æ”¶é›†æ‰€æœ‰ç­–ç•¥ä¿¡å·
        signals = [s.next() for s in self.strategies]
        
        # ç»Ÿè®¡æŠ•ç¥¨
        long_votes = signals.count(Position.LONG)
        short_votes = signals.count(Position.SHORT)
        exit_votes = signals.count(Position.EXIT)
        
        # è‡³å°‘ 2 ç¥¨æ‰æ‰§è¡Œ
        if long_votes >= 2:
            return Position.LONG
        elif short_votes >= 2:
            return Position.SHORT
        elif exit_votes >= 2:
            return Position.EXIT
        
        return None
```

### 3. ç­–ç•¥ç»„åˆï¼ˆPortfolioï¼‰

åŒæ—¶è¿è¡Œå¤šä¸ªç­–ç•¥ï¼Œåˆ†é…èµ„é‡‘ï¼š

```python
class StrategyPortfolio:
    """
    ç­–ç•¥ç»„åˆï¼šåŒæ—¶è¿è¡Œå¤šä¸ªç­–ç•¥ï¼Œåˆ†é…èµ„é‡‘
    
    ç¤ºä¾‹ï¼š
    - 50% èµ„é‡‘ï¼šRSI ç­–ç•¥ï¼ˆBTC/USDTï¼‰
    - 30% èµ„é‡‘ï¼šSMA ç­–ç•¥ï¼ˆETH/USDTï¼‰
    - 20% èµ„é‡‘ï¼šMACD ç­–ç•¥ï¼ˆBNB/USDTï¼‰
    """
    
    def __init__(self, total_cash=10000.0):
        self.total_cash = total_cash
        self.strategies = [
            {
                'name': 'RSI_BTC',
                'csv': 'data/btc-usdt-5m.csv',
                'strategy': RSIBacktraderStrategy,
                'params': {'rsi_period': 14},
                'allocation': 0.5
            },
            {
                'name': 'SMA_ETH',
                'csv': 'data/eth-usdt-5m.csv',
                'strategy': SMABacktraderStrategy,
                'params': {'short_period': 10, 'long_period': 30},
                'allocation': 0.3
            },
            {
                'name': 'MACD_BNB',
                'csv': 'data/bnb-usdt-5m.csv',
                'strategy': MACDBacktraderStrategy,
                'params': {},
                'allocation': 0.2
            }
        ]
    
    def run(self):
        results = []
        
        for strat_config in self.strategies:
            # åˆ†é…èµ„é‡‘
            allocated_cash = self.total_cash * strat_config['allocation']
            
            # è¿è¡Œå›æµ‹
            engine = BacktestEngine(
                initial_cash=allocated_cash,
                strategy_name=strat_config['name']
            )
            engine.setup(strat_config['strategy'], strat_config['params'])
            engine.load_data(strat_config['csv'])
            engine.run()
            
            final_value = engine.get_final_value()
            profit = final_value - allocated_cash
            
            results.append({
                'name': strat_config['name'],
                'initial': allocated_cash,
                'final': final_value,
                'profit': profit,
                'return_pct': profit / allocated_cash * 100
            })
        
        # æ±‡æ€»ç»“æœ
        total_final = sum(r['final'] for r in results)
        total_profit = total_final - self.total_cash
        
        print(f"\n{'='*60}")
        print("ç­–ç•¥ç»„åˆå›æµ‹ç»“æœ")
        print(f"{'='*60}")
        
        for r in results:
            print(f"\n{r['name']}:")
            print(f"  åˆå§‹èµ„é‡‘: {r['initial']:.2f} USDT")
            print(f"  æœŸæœ«èµ„é‡‘: {r['final']:.2f} USDT")
            print(f"  æ”¶ç›Š: {r['profit']:.2f} USDT ({r['return_pct']:.2f}%)")
        
        print(f"\n{'='*60}")
        print(f"ç»„åˆæ€»æ”¶ç›Š: {total_profit:.2f} USDT "
              f"({total_profit / self.total_cash * 100:.2f}%)")
        print(f"{'='*60}")
        
        return results

# è¿è¡Œç­–ç•¥ç»„åˆ
portfolio = StrategyPortfolio(total_cash=10000.0)
portfolio.run()
```

## âš¡ æ€§èƒ½è°ƒä¼˜

### 1. æ•°æ®é¢„åŠ è½½

é¿å…é‡å¤è¯»å– CSVï¼š

```python
import pandas as pd
import backtrader as bt

# è¯»å–ä¸€æ¬¡æ•°æ®
df = pd.read_csv('data/btc-usdt-5m.csv')
df['datetime'] = pd.to_datetime(df['datetime'])
df = df.set_index('datetime')

# å¤šæ¬¡å›æµ‹å¤ç”¨
for params in param_list:
    data = bt.feeds.PandasData(dataname=df)
    cerebro = bt.Cerebro()
    cerebro.adddata(data)
    cerebro.run()
```

### 2. ç¦ç”¨ä¸å¿…è¦çš„åŠŸèƒ½

```python
# ç¦ç”¨å›¾è¡¨ç”Ÿæˆï¼ˆå¤§å¹…æé€Ÿï¼‰
cerebro = bt.Cerebro(stdstats=False)

# ä½¿ç”¨ exactbars æ¨¡å¼ï¼ˆèŠ‚çœå†…å­˜ï¼‰
cerebro = bt.Cerebro(exactbars=-1)

# ç¦ç”¨è¯¦ç»†æ—¥å¿—
strategy_params = {'printlog': False}
```

### 3. å¹¶è¡Œä¼˜åŒ–

ä½¿ç”¨å¤šè¿›ç¨‹åŠ é€Ÿå‚æ•°ä¼˜åŒ–ï¼š

```python
from multiprocessing import Pool

def run_backtest_with_params(params):
    """å•æ¬¡å›æµ‹ä»»åŠ¡"""
    engine = BacktestEngine(initial_cash=10000.0)
    engine.setup(RSIBacktraderStrategy, params)
    engine.load_data('data/btc-usdt-5m.csv')
    engine.run()
    
    final_value = engine.get_final_value()
    return params, final_value

# ç”Ÿæˆå‚æ•°ç»„åˆ
param_combinations = []
for rsi_period in range(10, 21, 2):
    for rsi_oversold in range(20, 36, 5):
        for rsi_overbought in range(65, 81, 5):
            param_combinations.append({
                'rsi_period': rsi_period,
                'rsi_oversold': rsi_oversold,
                'rsi_overbought': rsi_overbought
            })

# å¹¶è¡Œè¿è¡Œ
with Pool(processes=4) as pool:  # 4 ä¸ªè¿›ç¨‹
    results = pool.map(run_backtest_with_params, param_combinations)

# æ‰¾åˆ°æœ€ä½³å‚æ•°
best_params, best_value = max(results, key=lambda x: x[1])
print(f"æœ€ä½³å‚æ•°: {best_params}, æœ€é«˜æ”¶ç›Š: {best_value:.2f}")
```

## ğŸš¨ å›æµ‹é™·é˜±ä¸é˜²èŒƒ

### 1. è¿‡æ‹Ÿåˆï¼ˆOverfittingï¼‰

**é—®é¢˜**ï¼šå‚æ•°åœ¨å†å²æ•°æ®ä¸Šè¡¨ç°å®Œç¾ï¼Œå®ç›˜å¤±æ•ˆã€‚

**é˜²èŒƒæªæ–½**ï¼š
- ä½¿ç”¨ Walk-Forward ä¼˜åŒ–
- ä¿ç•™æµ‹è¯•é›†ï¼ˆ30% æ•°æ®ä¸å‚ä¸ä¼˜åŒ–ï¼‰
- é™åˆ¶å‚æ•°èŒƒå›´ï¼ˆé¿å…è¿‡äºæç«¯çš„å€¼ï¼‰
- å…³æ³¨ç­–ç•¥é€»è¾‘åˆç†æ€§ï¼Œè€Œéå•çº¯è¿½æ±‚æ”¶ç›Š

```python
# âŒ é”™è¯¯ï¼šè¿‡åº¦ä¼˜åŒ–åˆ°å°æ•°ç‚¹
params = {'rsi_oversold': 29.873, 'rsi_overbought': 71.245}

# âœ… æ­£ç¡®ï¼šä½¿ç”¨æ•´æ•°æˆ–å¸¸è§å€¼
params = {'rsi_oversold': 30, 'rsi_overbought': 70}
```

### 2. æœªæ¥å‡½æ•°ï¼ˆLook-Ahead Biasï¼‰

**é—®é¢˜**ï¼šä½¿ç”¨äº†æœªæ¥æ•°æ®ï¼ˆå¦‚æ”¶ç›˜ä»·è®¡ç®—å¼€ç›˜ä¿¡å·ï¼‰ã€‚

**é˜²èŒƒæªæ–½**ï¼š
- ç¡®ä¿ `next()` ä¸­åªä½¿ç”¨ `[0]` æˆ–å†å²æ•°æ® `[-1], [-2]`
- é¿å…ä½¿ç”¨ `shift(-1)` ç­‰å‰ç»æ“ä½œ

```python
# âŒ é”™è¯¯ï¼šä½¿ç”¨äº†æœªæ¥æ•°æ®
def next(self):
    future_close = self.data.close[1]  # ä¸‹ä¸€æ ¹ K çº¿æ”¶ç›˜ä»·
    if future_close > self.data.close[0]:
        return Position.LONG

# âœ… æ­£ç¡®ï¼šåªä½¿ç”¨å½“å‰å’Œå†å²æ•°æ®
def next(self):
    current_close = self.data.close[0]
    prev_close = self.data.close[-1]
    if current_close > prev_close:
        return Position.LONG
```

### 3. å¹¸å­˜è€…åå·®ï¼ˆSurvivorship Biasï¼‰

**é—®é¢˜**ï¼šåªæµ‹è¯•ä»åœ¨äº¤æ˜“çš„å¸ç§ï¼Œå¿½ç•¥å·²ä¸‹æ¶çš„ã€‚

**é˜²èŒƒæªæ–½**ï¼š
- æµ‹è¯•å¤šä¸ªå¸ç§ï¼ˆåŒ…æ‹¬å°å¸‚å€¼å¸ï¼‰
- å…³æ³¨ç­–ç•¥åœ¨ç†Šå¸‚ä¸­çš„è¡¨ç°

### 4. äº¤æ˜“æˆæœ¬å¿½ç•¥

**é—®é¢˜**ï¼šæœªè€ƒè™‘æ‰‹ç»­è´¹ã€æ»‘ç‚¹ã€èµ„é‡‘è´¹ç‡ã€‚

**é˜²èŒƒæªæ–½**ï¼š
```python
# è®¾ç½®çœŸå®çš„äº¤æ˜“æˆæœ¬
cerebro.broker.setcommission(0.0004)  # 0.04% æ‰‹ç»­è´¹

# è®¾ç½®æ»‘ç‚¹
cerebro.broker.set_slippage_perc(0.001)  # 0.1% æ»‘ç‚¹

# è€ƒè™‘æœ€å°äº¤æ˜“é‡‘é¢
min_order_value = 10.0  # USDT
if order_value < min_order_value:
    return None  # ä¸äº¤æ˜“
```

### 5. æ•°æ®åå·®

**é—®é¢˜**ï¼šæ•°æ®è´¨é‡å·®ï¼ˆç¼ºå¤±ã€é”™è¯¯ï¼‰ã€‚

**é˜²èŒƒæªæ–½**ï¼š
```python
# æ•°æ®æ¸…æ´—
df = df.dropna()  # åˆ é™¤ç©ºå€¼
df = df[df['volume'] > 0]  # åˆ é™¤é›¶æˆäº¤é‡
df = df[df['high'] >= df['low']]  # åˆ é™¤å¼‚å¸¸æ•°æ®
```

## ğŸ”— å®ç›˜æ¥å…¥æŒ‡å—

### 1. æ¨¡æ‹Ÿç›˜æµ‹è¯•

åœ¨çœŸå®è´¦æˆ·å‰ï¼Œå…ˆç”¨æ¨¡æ‹Ÿç›˜éªŒè¯ï¼š

```python
import ccxt

# ä½¿ç”¨ Binance æ¨¡æ‹Ÿç›˜ï¼ˆtestnetï¼‰
exchange = ccxt.binance({
    'apiKey': 'YOUR_TESTNET_API_KEY',
    'secret': 'YOUR_TESTNET_SECRET',
    'options': {
        'defaultType': 'future',
        'test': True  # å¯ç”¨æµ‹è¯•ç½‘
    }
})

# æŸ¥è¯¢ä½™é¢
balance = exchange.fetch_balance()
print(f"USDT ä½™é¢: {balance['USDT']['free']}")

# ä¸‹å•æµ‹è¯•
order = exchange.create_market_buy_order(
    symbol='BTC/USDT',
    amount=0.001  # 0.001 BTC
)
print(f"è®¢å•ID: {order['id']}")
```

### 2. å®ç›˜é€‚é…å™¨

åˆ›å»º `src/live/live_trader.py`ï¼š

```python
import ccxt
import time
from src.strategy.RSIStrategy import RSIStrategy

class LiveTrader:
    """å®ç›˜äº¤æ˜“å™¨"""
    
    def __init__(self, api_key, api_secret, symbol='BTC/USDT'):
        self.exchange = ccxt.binance({
            'apiKey': api_key,
            'secret': api_secret,
            'options': {'defaultType': 'spot'}
        })
        
        self.symbol = symbol
        self.strategy = RSIStrategy(data=None, rsi_period=14)
        self.position = None  # å½“å‰ä»“ä½
    
    def run(self, interval=60):
        """
        è¿è¡Œå®ç›˜äº¤æ˜“
        
        Args:
            interval: æ£€æŸ¥é—´éš”ï¼ˆç§’ï¼‰
        """
        print(f"å®ç›˜äº¤æ˜“å·²å¯åŠ¨: {self.symbol}")
        
        while True:
            try:
                # è·å–æœ€æ–°æ•°æ®
                ohlcv = self.exchange.fetch_ohlcv(
                    self.symbol,
                    timeframe='5m',
                    limit=100
                )
                
                # è½¬æ¢ä¸ºç­–ç•¥å¯ç”¨æ ¼å¼
                closes = [candle[4] for candle in ohlcv]
                self.strategy.data.close = closes
                
                # ç”Ÿæˆä¿¡å·
                signal = self.strategy.next()
                
                # æ‰§è¡Œä¿¡å·
                if signal == Position.LONG and self.position != 'long':
                    self.execute_buy()
                    self.position = 'long'
                
                elif signal == Position.EXIT and self.position == 'long':
                    self.execute_sell()
                    self.position = None
                
                # ç­‰å¾…ä¸‹ä¸€ä¸ªå‘¨æœŸ
                time.sleep(interval)
            
            except Exception as e:
                print(f"é”™è¯¯: {e}")
                time.sleep(interval)
    
    def execute_buy(self):
        """æ‰§è¡Œä¹°å…¥"""
        balance = self.exchange.fetch_balance()
        usdt_balance = balance['USDT']['free']
        
        # ä½¿ç”¨ 95% èµ„é‡‘
        amount = (usdt_balance * 0.95) / self.get_current_price()
        
        order = self.exchange.create_market_buy_order(
            self.symbol,
            amount
        )
        
        print(f"âœ… ä¹°å…¥æˆåŠŸ: {amount:.4f} BTC @ {order['price']:.2f} USDT")
    
    def execute_sell(self):
        """æ‰§è¡Œå–å‡º"""
        balance = self.exchange.fetch_balance()
        btc_balance = balance['BTC']['free']
        
        order = self.exchange.create_market_sell_order(
            self.symbol,
            btc_balance
        )
        
        print(f"âœ… å–å‡ºæˆåŠŸ: {btc_balance:.4f} BTC @ {order['price']:.2f} USDT")
    
    def get_current_price(self):
        """è·å–å½“å‰ä»·æ ¼"""
        ticker = self.exchange.fetch_ticker(self.symbol)
        return ticker['last']

# ä½¿ç”¨æ–¹æ³•
if __name__ == '__main__':
    trader = LiveTrader(
        api_key='YOUR_API_KEY',
        api_secret='YOUR_API_SECRET',
        symbol='BTC/USDT'
    )
    
    trader.run(interval=300)  # æ¯ 5 åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
```

### 3. é£é™©ç®¡ç†

å®ç›˜äº¤æ˜“å¿…é¡»ä¸¥æ ¼é£é™©æ§åˆ¶ï¼š

```python
class RiskManager:
    """é£é™©ç®¡ç†å™¨"""
    
    def __init__(self, max_loss_per_trade=0.02, max_daily_loss=0.05):
        self.max_loss_per_trade = max_loss_per_trade  # å•ç¬”æœ€å¤§äºæŸ 2%
        self.max_daily_loss = max_daily_loss          # å•æ—¥æœ€å¤§äºæŸ 5%
        
        self.daily_start_balance = None
        self.trades_today = []
    
    def check_position_size(self, balance, price):
        """æ£€æŸ¥ä»“ä½å¤§å°"""
        max_position_value = balance * self.max_loss_per_trade
        max_amount = max_position_value / price
        return max_amount
    
    def check_daily_limit(self, current_balance):
        """æ£€æŸ¥æ¯æ—¥äºæŸé™åˆ¶"""
        if self.daily_start_balance is None:
            self.daily_start_balance = current_balance
        
        daily_loss = (self.daily_start_balance - current_balance) / self.daily_start_balance
        
        if daily_loss > self.max_daily_loss:
            print(f"âš ï¸ è§¦å‘æ¯æ—¥äºæŸé™åˆ¶: {daily_loss*100:.2f}%")
            return False  # åœæ­¢äº¤æ˜“
        
        return True  # å…è®¸äº¤æ˜“
```

## â“ å¸¸è§é—®é¢˜FAQ

### Q1: å›æµ‹æ”¶ç›Šå¾ˆé«˜ï¼Œå®ç›˜äºæŸæ€ä¹ˆåŠï¼Ÿ

**A1ï¼š** è¿™æ˜¯æœ€å¸¸è§çš„é—®é¢˜ï¼ŒåŸå› å¯èƒ½æ˜¯ï¼š
1. **è¿‡æ‹Ÿåˆ**ï¼šå‚æ•°åœ¨å†å²æ•°æ®ä¸Šè¿‡åº¦ä¼˜åŒ–
   - è§£å†³ï¼šä½¿ç”¨ Walk-Forward ä¼˜åŒ–ï¼Œä¿ç•™æµ‹è¯•é›†
2. **æœªæ¥å‡½æ•°**ï¼šå›æµ‹ä¸­ä½¿ç”¨äº†æœªæ¥æ•°æ®
   - è§£å†³ï¼šä»”ç»†æ£€æŸ¥ç­–ç•¥ä»£ç ï¼Œç¡®ä¿åªç”¨å†å²æ•°æ®
3. **äº¤æ˜“æˆæœ¬**ï¼šå®ç›˜æœ‰æ‰‹ç»­è´¹ã€æ»‘ç‚¹
   - è§£å†³ï¼šå›æµ‹æ—¶è®¾ç½®çœŸå®çš„äº¤æ˜“æˆæœ¬
4. **å¸‚åœºç¯å¢ƒå˜åŒ–**ï¼šç­–ç•¥é€‚åº”çš„å¸‚åœºçŠ¶æ€æ”¹å˜
   - è§£å†³ï¼šå®šæœŸé‡æ–°ä¼˜åŒ–å‚æ•°ï¼Œæˆ–ä½¿ç”¨è‡ªé€‚åº”ç­–ç•¥

### Q2: å¦‚ä½•åˆ¤æ–­ç­–ç•¥æ˜¯å¦è¿‡æ‹Ÿåˆï¼Ÿ

**A2ï¼š** æ£€æŸ¥ä»¥ä¸‹æŒ‡æ ‡ï¼š
- **æ ·æœ¬å†… vs æ ·æœ¬å¤–**ï¼šæµ‹è¯•é›†æ”¶ç›Šè¿œä½äºè®­ç»ƒé›† â†’ è¿‡æ‹Ÿåˆ
- **å‚æ•°æ•æ„Ÿæ€§**ï¼šå‚æ•°å¾®å°å˜åŒ–å¯¼è‡´æ”¶ç›Šå‰§å˜ â†’ è¿‡æ‹Ÿåˆ
- **äº¤æ˜“æ¬¡æ•°**ï¼šäº¤æ˜“æ¬¡æ•°è¿‡å°‘ï¼ˆ< 30 æ¬¡ï¼‰â†’ ç»Ÿè®¡ä¸æ˜¾è‘—
- **æœ€å¤§å›æ’¤**ï¼šå›æ’¤è¿‡å¤§ï¼ˆ> 30%ï¼‰â†’ é£é™©è¿‡é«˜

```python
# æ ·æœ¬å¤–æµ‹è¯•
train_df = df[:'2024-06-30']
test_df = df['2024-07-01':]

# è®­ç»ƒé›†ä¼˜åŒ–å‚æ•°
best_params = optimize(train_df)

# æµ‹è¯•é›†éªŒè¯
train_return = backtest(train_df, best_params)
test_return = backtest(test_df, best_params)

if test_return < train_return * 0.5:
    print("âš ï¸ å¯èƒ½å­˜åœ¨è¿‡æ‹Ÿåˆ")
```

### Q3: ç­–ç•¥åœ¨ä¸åŒå¸ç§è¡¨ç°å·®å¼‚å¤§æ€ä¹ˆåŠï¼Ÿ

**A3ï¼š** è¿™æ˜¯æ­£å¸¸ç°è±¡ï¼Œå¯ä»¥ï¼š
1. **åˆ†å¸ç§ä¼˜åŒ–**ï¼šä¸ºæ¯ä¸ªå¸ç§å•ç‹¬ä¼˜åŒ–å‚æ•°
2. **é€‰æ‹©é€‚åˆçš„å¸ç§**ï¼šé€‰æ‹©ä¸ç­–ç•¥é€»è¾‘åŒ¹é…çš„å¸ç§
   - RSI ç­–ç•¥ï¼šé€‚åˆéœ‡è¡å¸‚ï¼ˆETH/USDTï¼‰
   - å‡çº¿ç­–ç•¥ï¼šé€‚åˆè¶‹åŠ¿å¸‚ï¼ˆBTC/USDTï¼‰
3. **ä½¿ç”¨è‡ªé€‚åº”å‚æ•°**ï¼šæ ¹æ®å¸ç§æ³¢åŠ¨ç‡åŠ¨æ€è°ƒæ•´

### Q4: å¦‚ä½•åŠ é€Ÿå‚æ•°ä¼˜åŒ–ï¼Ÿ

**A4ï¼š** 
1. **å‡å°‘æ•°æ®é‡**ï¼šä½¿ç”¨æ›´å¤§æ—¶é—´å‘¨æœŸï¼ˆ5m â†’ 15mï¼‰
2. **ç¼©å°å‚æ•°èŒƒå›´**ï¼šåªä¼˜åŒ–å…³é”®å‚æ•°
3. **ä½¿ç”¨å¹¶è¡Œè®¡ç®—**ï¼šå¤šè¿›ç¨‹/å¤šçº¿ç¨‹
4. **ç¦ç”¨å›¾è¡¨å’Œæ—¥å¿—**ï¼š`cerebro = bt.Cerebro(stdstats=False)`

### Q5: å®ç›˜å¦‚ä½•ç›‘æ§ç­–ç•¥è¿è¡Œï¼Ÿ

**A5ï¼š** 
1. **æ—¥å¿—è®°å½•**ï¼šè®°å½•æ¯ç¬”äº¤æ˜“ã€ä½™é¢å˜åŒ–
2. **å®æ—¶é€šçŸ¥**ï¼šé€šè¿‡é’‰é’‰/å¾®ä¿¡/é‚®ä»¶å‘é€äº¤æ˜“é€šçŸ¥
3. **æ€§èƒ½ç›‘æ§**ï¼šå®šæœŸè®¡ç®—å¤æ™®æ¯”ç‡ã€æœ€å¤§å›æ’¤
4. **å¼‚å¸¸æŠ¥è­¦**ï¼šä½™é¢å¼‚å¸¸å˜åŒ–ã€è®¢å•å¤±è´¥

```python
import requests

def send_dingtalk_notification(message):
    """å‘é€é’‰é’‰é€šçŸ¥"""
    webhook = 'YOUR_DINGTALK_WEBHOOK'
    data = {
        "msgtype": "text",
        "text": {"content": message}
    }
    requests.post(webhook, json=data)

# ä½¿ç”¨
send_dingtalk_notification(f"âœ… ä¹°å…¥æˆåŠŸ: 0.001 BTC @ 66500 USDT")
```

## ğŸ“¦ é¡¹ç›®éƒ¨ç½²

### 1. Docker éƒ¨ç½²

åˆ›å»º `Dockerfile`ï¼š

```dockerfile
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ä¾èµ–
COPY pyproject.toml .
RUN pip install -e .

# å¤åˆ¶ä»£ç 
COPY . .

# è¿è¡Œå›æµ‹
CMD ["python", "script/run_backtest.py"]
```

æ„å»ºå’Œè¿è¡Œï¼š

```bash
docker build -t cryptoquant .
docker run -p 8765:8765 cryptoquant
```

### 2. å®šæ—¶ä»»åŠ¡

ä½¿ç”¨ `cron` å®šæ—¶è¿è¡Œå›æµ‹ï¼š

```bash
# ç¼–è¾‘ crontab
crontab -e

# æ¯å¤©å‡Œæ™¨ 2 ç‚¹è¿è¡Œå›æµ‹
0 2 * * * cd /path/to/CryptoQuant && python script/run_backtest.py >> logs/backtest.log 2>&1
```

### 3. äº‘æœåŠ¡å™¨éƒ¨ç½²

åœ¨ AWS/é˜¿é‡Œäº‘/è…¾è®¯äº‘ä¸Šéƒ¨ç½²ï¼š

```bash
# è¿æ¥æœåŠ¡å™¨
ssh user@your-server-ip

# å…‹éš†é¡¹ç›®
git clone https://github.com/your-repo/CryptoQuant.git
cd CryptoQuant

# å®‰è£…ä¾èµ–
pip install -e .

# åå°è¿è¡Œï¼ˆä½¿ç”¨ nohupï¼‰
nohup python script/run_backtest.py > backtest.log 2>&1 &

# æŸ¥çœ‹æ—¥å¿—
tail -f backtest.log
```

---

ğŸ‰ **æ­å–œï¼** ä½ å·²ç»æŒæ¡äº† CryptoQuant çš„æ‰€æœ‰æ ¸å¿ƒåŠŸèƒ½ã€‚ç°åœ¨å¼€å§‹æ„å»ºè‡ªå·±çš„é‡åŒ–äº¤æ˜“ç³»ç»Ÿå§ï¼

ğŸ“š **æ›´å¤šèµ„æºï¼š**
- [Backtrader å®˜æ–¹æ–‡æ¡£](https://www.backtrader.com/docu/)
- [CCXT äº¤æ˜“æ‰€æ¥å£æ–‡æ¡£](https://docs.ccxt.com/)
- [TA-Lib æŠ€æœ¯æŒ‡æ ‡åº“](https://ta-lib.org/)
- [TradingView å›¾è¡¨åº“](https://www.tradingview.com/lightweight-charts/)
